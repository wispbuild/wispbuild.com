---
title: Your First Build System
sidebar_position: 2
---

# Your First Build System

How can something as simple as `cc main.c && ./a.out` be a build system? It actually implements all of the basic features of a build system! It defines:

1. the inputs: `main.c`,
2. the tasks to perform: `cc`, `a.out`,
3. and, the relationship between the tasks: `&&`.

Over the course of this guide we'll slowly expand and revise this definition, but this is a fine place to start.

## The Inputs

In any build system you must tell your tasks what to operate on. In this example that is your source code, `main.c`. In spite of this example's apparent simplicity, defining your inputs is actually the most-difficult part of telling your build system what you want it to do.

We software developers write software to take input—from users, from systems—and process that input into _new_ information that benefits us. A build system is no different. This gets hard precisely because we generally get better outputs with more (and better) inputs.

## The Tasks

In this example you need to compile the code and you need to run it so you can inspect the output. Many computers ship with a C compiler, `cc`, making it possible for you to simply call it.

And then, since `a.out` is a file generated by `cc`, it'll definitely be there by the time we invoke it.

## The Relationships

There are actually two pieces of information encoded in the `&&`. The first is order, and the second is an execution condition.

Since we always compile `main.c` before executing `a.out`, we know for certain that any time we execute 

## Visualizing

The 

### Code!

### Math!

### Charts!

***

This is a good mental model for your first build system, but industrial-grade build systems can do a lot more.